using CommandLine;
using Microsoft.WindowsAzure.Storage;
using Microsoft.WindowsAzure.Storage.Auth;
using Microsoft.WindowsAzure.Storage.Blob;
using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Security.Cryptography;
using System.Threading.Tasks;
using System.Xml.Linq;

namespace SimplyUpdate.BuildUpdate
{
	class Program
	{
		public static int Main(string[] args)
		{
			return CommandLine.Parser.Default.ParseArguments<AzureOptions, PathOptions>(args)
							.MapResult(
								(AzureOptions opts) => SendToAzure(opts).Result,
								(PathOptions opts) => SendToPath(opts),
								errs => 1);
		}

		public static async Task<int> SendToAzure(AzureOptions opts)
		{
			CloudBlockBlob zipSnapshot = null;
			CloudBlockBlob zipBlob = null;
			try
			{
				var zipFile = CreateZipFile(opts.Source);

				Console.WriteLine("Upload zip file.");
				var storageCredentials = new StorageCredentials(opts.AccountName, opts.AccountKey);
				var cloudStorageAccount = new CloudStorageAccount(storageCredentials, true);
				var cloudBlobClient = cloudStorageAccount.CreateCloudBlobClient();

				var container = cloudBlobClient.GetContainerReference(opts.ContainerName);
				await container.CreateIfNotExistsAsync();

				zipBlob = container.GetBlockBlobReference(opts.Destination + "/software.zip");

				if (await zipBlob.ExistsAsync())
					zipSnapshot = await zipBlob.CreateSnapshotAsync();
				await zipBlob.UploadFromFileAsync(zipFile);

				Console.WriteLine("Update version.");
				var xmlBlob = container.GetBlockBlobReference(opts.Destination + "/software.xml");

				var doc = CreateOrUpdateVersionFile(
					await xmlBlob.ExistsAsync() ? XDocument.Parse(await xmlBlob.DownloadTextAsync()) : null,
					zipFile,
					opts
					);

				//if (await xmlBlob.ExistsAsync())
				//	await xmlBlob.CreateSnapshotAsync();
				await xmlBlob.UploadTextAsync(doc.ToString());

				await zipSnapshot?.DeleteAsync();
				File.Delete(zipFile);

				return 0;
			}
			catch(Exception ex)
			{
				if (zipBlob != null && zipSnapshot != null) 
				{
					await zipBlob.StartCopyAsync(zipSnapshot);
					await zipSnapshot.DeleteAsync();
				}
				Console.WriteLine(ex.Message);
				return 1;
			}
		}

		private static XDocument CreateOrUpdateVersionFile(XDocument currentFile, String zipFile, BaseOptions opts)
		{
			XDocument retVal= new XDocument(
								new XDeclaration("1.0", "UTF-8", "yes"),
								new XComment("\nSimply Update version file\nGenerated by SimplyUpdate.BuildUpdate (https://github.com/Artusoft/SimplyUpdate.BuildUpdate)\n"),
								new XElement("Liveupdate",
								new XElement("Version", 0)
								));

			Int32 previousVer = 0;
			if (currentFile != null)
			{
				var ndVersion = retVal.Descendants("Version").FirstOrDefault();
				Int32.TryParse(ndVersion.Value, out previousVer);
			}

			var nd = retVal.Descendants("Version").FirstOrDefault();
			Int32 currentVer = 0;
			if (nd != null)
				if (opts.Version != 0)
					nd.Value = (currentVer = opts.Version).ToString();
				else
					nd.Value = (currentVer = previousVer + 1).ToString();

			Console.WriteLine("Hashing zip file.");
			var MD5Hash = ComputeHash(zipFile);
			nd = retVal.Descendants("MD5").FirstOrDefault();
			if (nd == null)
				retVal.Element("Liveupdate").Add(new XElement("MD5", Convert.ToBase64String(MD5Hash)));
			else
				nd.Value = Convert.ToBase64String(MD5Hash);

			nd = retVal.Descendants("FileLenght").FirstOrDefault();
			if (nd == null)
				retVal.Element("Liveupdate").Add(new XElement("FileLenght", (new System.IO.FileInfo(zipFile)).Length));
			else
				nd.Value = (new System.IO.FileInfo(zipFile)).Length.ToString();

			Console.WriteLine($"Version {previousVer} -> {currentVer}");

			return retVal;
		}

		private static String CreateZipFile(String source)
		{
			DirectoryInfo pathSource = new DirectoryInfo(source);

			if (!pathSource.Exists) return String.Empty;

			String pathTemp = Path.Combine(Path.GetTempPath(), "SimplyUpdate");
			if (!Directory.Exists(pathTemp)) Directory.CreateDirectory(pathTemp);

			String zipFile = Path.Combine(pathTemp, "software.zip");
			if (File.Exists(zipFile)) File.Delete(zipFile);

			List<String> files = new List<string>();

			files.AddRange(from f in pathSource.GetFiles("*.dll", SearchOption.AllDirectories)
										 select f.FullName);
			files.AddRange(from f in pathSource.GetFiles("*.config", SearchOption.AllDirectories)
										 select f.FullName);
			files.AddRange(from f in pathSource.GetFiles("*.json", SearchOption.AllDirectories)
										 select f.FullName);
			files.AddRange(from f in pathSource.GetFiles("*.exe", SearchOption.AllDirectories)
										 where !f.Name.Contains("vshost")
										 select f.FullName);

			Console.WriteLine("Zip files.");
			using (ZipArchive archive = ZipFile.Open(zipFile, ZipArchiveMode.Create))
				files.ForEach(f =>
				{
					var filename = f.Remove(0, pathSource.FullName.Length + 1);
					Console.Write("Zip file " + filename);
					archive.CreateEntryFromFile(f, filename, CompressionLevel.Optimal);
					Console.WriteLine(" .. OK");
				});

			return zipFile;
		}

		public static int SendToPath(PathOptions opts)
		{
			var zipFile = CreateZipFile(opts.Source);

			Console.WriteLine("Copy zip file.");

			File.Copy(zipFile, Path.Combine(opts.Destination, "software.zip"), true);

			Console.WriteLine("Update version.");
			var xmlFile = Path.Combine(opts.Destination, "software.xml");
			XDocument currentDoc = null;
			if (File.Exists(xmlFile))
				currentDoc = XDocument.Load(xmlFile);

			var doc = CreateOrUpdateVersionFile(
				currentDoc,
				zipFile,
				opts
				);
			
			doc.Save(xmlFile);

			File.Delete(zipFile);

			return 0;
		}

		private static Byte[] ComputeHash(String filePath)
		{
			byte[] hashValue;

			using (MD5 myMD5 = MD5.Create())
			using (FileStream fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read))
			{
				hashValue = myMD5.ComputeHash(fileStream);
				fileStream.Close();
			}

			return hashValue;
		}
	}
}
